15-三数之和

如果直接三重循环，O(n^3)不可取。双指针方法通常能够降低时间复杂度，如O(n^2) -> O(n)。

注意：遇到相同的元素需要跳过，否则会引入重复的情况。

哈希法空间复杂度可能过高了。

时间复杂度：O(N^2)（排序占用了O(NlogN)），空间复杂度：O(log N)-修改原数组  O(N)-创建新数组

------

16-最接近的三数之和

同样使用双指针，区别在于：每次判断current result和target的位置关系，对应移动second**或**third。

注意：这个answer初始化要看定义的target范围。

时间复杂度：O(N^2)（排序占用了O(NlogN)），空间复杂度：O(log N)-修改原数组  O(N)-创建新数组

------

18-四数之和

双指针，二重循环+双指针。

二重循环中加入极端位置的判断，可减少循环次数。

判断current result和target的位置关系，对应移动最后两个指针。

时间复杂度：O(N^3) (优于O(N^4))

------

31-下一个排列

本题的重点是找出本排列到下一个排列的规律

从左到右找到最后一个相邻升序对(left, right)，最后一个相邻升序对的右侧为单调递减，最小值（**若左右相等，取右边**）与left进行比较，若大于left，则更新right值。

注：为什么要找右侧为单调递减呢？因为单调递减意味着是这一个子序列的最后一个排列情况。设想一个特殊情形：整个序列是逆序的，那么下一个排列就是从头开始的顺序排列。

确定left和right之后，交换对应位置的值，然后对left右侧（单调递减）进行逆序操作（单调递增）

注意：标粗的地方即代码中line 24，e.g. 寻找1,3,3的下一个排列时，1先和后面的3交换，而不是前面的3，然后再做逆序

P.S.：Java中Arrays没有定义reverse()方法，需要自己写

P.S.：一开始自己写的时候用的是Arrays.sort(int[] a, int fromIndex, int toIndex)，时间复杂度不如arrayReverse()操作，并且注意toIndex是不被包括进去的，类似python的range()

时间复杂度：O(N)，空间复杂度：O(1)

------

33-搜索旋转排序数组

核心思想：将数组一分为二，则其中一部分包含旋转点，另一部分不包含。即一部分有序，一部分无序。

通过有序部分的两个端点判断target在哪里，从而确定下一步查找的范围。

注意：寻找旋转点不可取，时间复杂度O(N)。

P.S.：好好练练二分查找的熟练度吧2333

时间复杂度：O(logN)

------

34-在排序数组中查找元素的第一个和最后一个位置

两种实现思路：

- (a) 当产生匹配时，并不结束查找，而是分头向两边寻找是否有比mid更宽的边界
- (b) 首先查找左边界，然后查找右边界

代码细节：

(b)方法写起来更为简洁，但注意求出左边界后要判断左边界是否合法，以及求出右边界需要减1的细节。

时间复杂度：O(logN)

------

39-组合总和

要点：搜索回溯算法，深度优先搜索

深度优先搜索本质是一个递归的过程，回溯部分需要调用递归函数的后面（remove部分）

问题：对原列表排序能否提高效率？应该升序排列还是降序排列？

时间复杂度：O(S)，S为所有可行解长度（但实际上运行过程中还会经历一些不可行的解？e.g.  [2,6,7]  target = 7，那么[2,2,2]会出现在遍历过程中，但实际并不成立）。因此，感觉写成 O(搜索树深度) 更精确，但不够S清晰。

空间复杂度：O(target)，最坏情况1,1,...,1

------

40-组合总和 II

要点：搜索回溯算法，深度优先搜索，39的进阶

与q39最大的不同：如何处理有重复元素的情况？使用q39的方法会导致出现重复结果

解决方案：对原数据排序后，构造一个 <数据 : 频率> 的“字典”（注：对顺序有要求，因此HashMap不可取），对这个字典进行迭代而不是原列表，从而规避重复元素。

在dfs的实现过程中，找出当前元素最多能使用的次数，进行迭代。

注意：dfs的搜索成功判断要放在终止条件前，否则搜索结果不会被加入最终输出（只剩几个空括号......）

时间复杂度：O(N * 2^N)（N为数组长度，一个非常松的上界），最坏的情况下，所有数都不同，且所有数的和小于target，那么所有情况都会被遍历到（早期终止条件不会成立）。最坏情况下，排序时间O(NlogN)可忽略不计。

空间复杂度：O(N)（使用了额外的字典）

------

48-旋转图像

重点：先转置，然后左右翻转

时间复杂度：O(N^2)（以转置为例，交换操作要进行(N^2-N)/2次）

空间复杂度：O(1)

------

54-螺旋矩阵

重点：一圈一圈的迭代，只需不断缩小边界即可。注意边界条件。

时间复杂度：O(mn)，即矩阵中每个元素遍历一次

空间复杂度：O(1)

------

55-跳跃游戏

重点：贪心算法，每次记录最远距离，迭代中若index超过最远距离则无法到达

别把这个问题想太复杂。以及要了解贪心算法：

局部最优解能否推出全局最优解？可以的话贪心算法可行，拆分全局的问题为局部问题。

例如：本题中，对于每一个点，我们能够找到**当前**能够到达的最远距离，在这个点到最远距离的所有点中，我们又去找对于每一个点的最远距离，以此更新能到达的最远距离。最终找到全局最远距离。

时间复杂度：O(N)，N为数组长度

空间复杂度：O(1)

------

5-最长回文子串

重点：动态规划

思路：对于一个回文串，判断该串左右字符是否相等，相等的话则回文串增长。

边界情况：奇数字符回文串（aba），边界情况可认为是只有一个字符；偶数字符回文串（abba），边界情况可认为是相邻两个字符相等

实现过程中的一个细节问题：我是直接创建空字符串，然后通过加法不断更新字符串，似乎这样的运行速度有点慢（但也是能通过的）？

时间复杂度：O(N^2)，极端情况下，向两边扩展的次数为0,1,2,...,N/2,...,2,1,0，求和可知是N^2量级

空间复杂度：O(N)，按我的实现方式，每次用当前回文子串和存储的已知最长子串对比，因此只需要O(N)空间即可

------

62-不同路径

重点：数学思路 or 动态规划

数学思路：可以转化为m+n-2个相同单位中抽n-1个的组合数问题

动态规划：每个点的值等于他左边点的值加上他上面点的值，因此，我们每次保存上一行，就可以计算出这一行的所有结果。

注意：使用Java写组合数计算方法，由于题目中m, n取值较大，不能直接计算m+n-2的阶乘，否则会溢出。应该采取别的计算组合数的方法，所以我代码中的是未通过版本。但主要思想到位了就可以，
重点放在动态规划上吧。

（以下复杂度基于动态规划的实现讨论）

时间复杂度：O(mn)，需要遍历每一个点

空间复杂度：O(2n)，只需要储存当前行和上一行就能进行计算了

------

63-不同路径 II

重点：动态规划

和q62的动态规划思路基本完全相同，加入障碍物：某一点存在障碍物时，该点放弃原有赋值方法，直接取0就可以

注意：注意一下几个边界情况（起点存在障碍物，第一行或第一列存在障碍物，只有一行或一列，只有一个点）

时间复杂度：O(mn)，需要遍历每一个点（和q62是相同的）

空间复杂度：O(2n)，只需要储存当前行和上一行就能进行计算了（和q62是相同的）

------

64-最小路径和

重点：动态规划

思路：本题和q62以及q63没有本质区别。想清楚一点：之前两道题都是从左上到右下求解，本题是从右下往左上求解。

动态规划方程：每一个点的最小路径和 = min(右边邻居的最小路径，下面邻居的最小路径) + 本点的值

时间复杂度：O(mn)

空间复杂度：O(2n)

------

91-解码方法

重点：动态规划

动态规划方程：dp[i] = dp[i-1] * I(i处数字不为0) + dp[i-2] * I(i-1和i处的数字组成合法两位数，即在[10,26]区间内)

代码里留了两种主要思想相同的实现方法，第一种的写法更符合我刚开始的思考方式，第二种使用数组解决问题，更加直观。

时间复杂度：O(N)，遍历整个字符串

空间复杂度：O(1)，第一种写法，只记录前两次的计算结果；O(N)，第二种写法，创建一个数组保留每次计算结果

------

95-不同的二叉搜索树 II

重点：递归 or 动态规划

对比之下，递归还是最容易想到的...

动态规划有两种思路：

- (1) 储存所有的解，即dp[0], dp[1],..., dp[n]，对于dp[i]，确定根节点j后，左边即是dp[j-1]，右边是dp[i-j]加上一个偏差之后的结果

这个思路非常巧妙：这个问题的一个trick在于，例如某次分割下右子树中有i-j个连续元素，这i-j个连续元素生成的BST个数和1,2,...,i-j生成的BST个数相同，结构相同，唯一的
区别就是需要在1,2,...,i-j生成的BST上加上一个偏差值

- (2) 储存上一次计算得到的值，插入一个新的最大值，有且仅有这些情况：作为新的根节点 or 作为根节点的右子树根节点 or 根节点的右子树的右子树的根节点 ... and so on

需要找出最多可以向右走多少步，每走一步均可以生成新的结果

时间复杂度：可行BST的个数为Gn，生成一棵BST时间为O(n)，总体时间复杂度为：O(nGn)，Gn即是数学上的卡特兰数，其增长速度为 4^n / (n^(3/2))，故总时间复杂度为O(4^n / (n^(1/2)))

空间复杂度：O(4^n / (n^(1/2)))，与时间复杂度相同，个人理解：由于增长速度过快，递归所需栈空间 and 方法三动态规划省略的前n-1次结果，都可以忽略不计？（并没有严谨考察）

------

96-不同的二叉搜索树

重点：动态规划

弄懂了q95的动态规划思路(1)，这道题就会非常简单。动态规划方程：dp[i] += dp[j-1] * dp[i-j];  (j from 1 to i)

时间复杂度：O(n^2)，查看代码中循环可知

空间复杂度：O(n)，存储动态规划数组

------

120-三角形最小路径和

重点：动态规划

从上到下求解，只需O(n)空间，每次在原数组上更新值即可。

从右往左更新就可以避免覆盖掉所需数值的问题。每一个点的路径来自于上一行下标相同的点或上一行下标-1的点，因此，从右往左更新时，覆盖掉的点不会用于求下一个点的值。

时间复杂度：O(n^2)

空间复杂度：O(n)

------

139-单词拆分

重点：动态规划

动态规划方程：dp[i] = dp[j] && check(s[j,...,i-1]) （每次加入新字符时，判断和之前所有字符组成的划分能不能被字典中的单词拆分）

注意：j（即划分位置）从右往左会减少查找需要的次数

时间复杂度：O(n^2)，对于长度为n的字符串，有n种划分，因此需要运行1,2,...,n次，故为n^2时间

空间复杂度：O(n)，使用了HashSet以及动态规划数组

------

152-乘积最大子数组

重点：动态规划（特殊）

维护**两个**动态规划数组，一个存储当前连续最大值，一个存储当前连续最小值。

每次引入新数字时，对于最大值DP数组存在这样的情况：最大值更大，最小值变为最大，nums[i]单独最大

对于最小值DP数组则是对应的相反的情况

最后比较最大值DP数组中的数值

时间复杂度：O(n)

空间复杂度：O(n)，常系数为2，引入了两个DP数组

------

6-Z字形变换

重点：字符串处理

使用两个循环固然可行，但并不直观。使用一个储存StringBuilder的List，储存每一行的情况。

只需从头遍历到结尾即可把每个字符加到其对应的行中。（使用了一个布尔变量getDown判断是进入下一行还是上一行，在拐角处修改getDown）

标准答案里创建的行数是取numRows和s.length()的最小值，也可直接写numRows，并不是必须。

时间复杂度：O(N)，N为字符串长度，遍历整个字符串

空间复杂度：O(N)

------

8-字符串转换整数 (atoi)

重点：字符串处理，确定有限状态机（DFA）

做题的时候状态好的话，用if-else判断也没有非常臃肿，但要确保自己考虑到了方方面面。但DFA作为一个更条理更清晰的知识，也建议学习一下。

有限状态机：我的理解是，把字符串的遍历过程中的处理方法作为这个字符串的状态，各个状态组成一个有向图，有固定的转换规则，对于同一状态下的
不同字符均可采用同样的处理方式（见get方法），显得更为简洁。

注意：使用long处理结果以防溢出，负数比较的时候是和 - (long) Integer.MIN_VALUE 比较，因为ans是去掉符号后的结果

时间复杂度：O(N)，N为字符串长度，遍历整个字符串

空间复杂度：O(1)，自动机只需O(1)空间

------

12-整数转罗马数字

重点：贪心算法

两种方法：1) 从最大情况到最小情况依次查找并添加结果；2) 硬编码，把每一位上的所有可能情况列出来

时间复杂度：O(1)，由于题目限定数字的取值范围，因此迭代次数上限是可预知的

空间复杂度：O(1)，额外空间长度不随数字改变而改变

------

17-电话号码的字母组合

重点：DFS，回溯

这道题是非常标准的考察DFS + 回溯的题目，需要自己能够快速写出解答，但是要注意一些细节。

注意：可以在method外定义变量，这样dfs方法的参数会少很多，更加简洁。遇到非2-9的字符需要跳过（这一点标答中似乎没有考虑？）。另一个细节问题，
如果在method内定义变量，把定义的哈希表传入dfs的时候，一定要具体写出内部储存元素的类型，否则会报错的。

时间复杂度：O(3^m x 4^n)，其中m为对应3个字母的数字（2,3,4,5,6,8），n为对应4个字母的数字（7,9），也就是可行解的个数（通常情况下的dfs搜索复杂度）

空间复杂度：O(m + n)，不考虑返回值的情况。空间复杂度取决于：递归深度（m + n），以及哈希表存储空间（常数空间）。

------

10-正则表达式匹配

重点：动态规划

想到对string和pattern同时进行动态规划非常重要。匹配到 * 号既可以是dp[i-1][j]，即去除字符串末尾一位后继续匹配，
也可以是dp[i][j-2]，即 * 号前面那个字符匹配了0次。

动态规划方程如下：

![q10](./pics/q10.JPG)

时间复杂度：O(mn)，遍历动态规划数组

空间复杂度：O(mn)

------

22-括号生成

重点：DFS，回溯

同样是非常标准的DFS，实现过程中需要注意的一个原则：在一个结果中，从左到右进行统计时，左括号的数量始终大于等于右括号数量，所以我写的时候
加了left和right两个参数示意待添加的左括号和右括号数量

时间复杂度：卡特兰数增长速度为 4^n / (n^(3/2))，复制每一个可行解到结果中需要O(n)时间，故总时间复杂度为O(4^n / (n^(1/2)))

空间复杂度：取决于递归栈的深度，每一层递归函数需要O(1)的空间，最多递归2n层，因此空间复杂度为 O(n)

------

43-字符串相乘

重点：字符串处理，数学问题

方法1：模拟竖式乘法的过程，num1的整体和num2的每一位相乘，然后结果按规则相加

注意：使用StringBuilder或者StringBuffer，数字可直接使用append()方法，append()方法重载了多次（char, int, long, float...），不需要加48后显式转换

时间复杂度（方法1）：O(mn + n ^ 2)，计算乘法过程中需要O(mn)时间，每次阶段结果相加时，字符串最长为m + n，相加n次，因此加法操作需要O((m + n) x n)时间

空间复杂度（方法1）：O(m + n)，存储的字符串的长度最大为O(m + n)

方法2：创建一个长数组，每次维护数组内的值

首先我们需要知道，m位的数字和n位的数字相乘，结果至多为m + n位，至少为m + n - 1位

步骤：

- 第一个数第i位和第二个数第j位相乘，结果进入长数组的i + j + 1位

- 从后往前维护进位

- 最后，长数组转换为字符串输出

时间复杂度（方法2）：O(mn)，观察上述步骤，相乘过程时间复杂度为O(mn)，维护进位和字符串转换需要O(m + n)

空间复杂度（方法3）：O(m + n)，需要一个长数组

------

49-字母异位词分组

重点：哈希表

方法1：每个字符串排序后的结果作为哈希表的key值

方法2：自行构建散列函数，"#2#1...#0"这样的形式

假设字符串数组长度为N，每个字符串长度为K

时间复杂度：O(NKlogK)(方法1)，O(NK)(方法2)，可见排序并不是这个问题中的最优解

空间复杂度：O(NK)

------

71-简化路径

重点：字符串处理，栈和队列

使用字符串的split函数，传入"/"作为参数（注意传入参数必须为字符串）

使用双向队列更容易处理，使用栈亦可。

时间复杂度：O(N)，其中N为最初输入的path长度

空间复杂度：O(N)

------

29-两数相除

重点：32位有符号整数的越界条件判断，指数递增查找，递归

将dividend分别除以divisor的1,2,4,8...倍（可以通过自加运算实现），确定范围后递归查询精确结果

这道题重点在：第一，确定这个**指数递增查找**的思路；第二，判断越界条件。以下重点讲讲越界情况：

- dividend = Integer.MIN_VALUE, divisor = -1    题目条件中说如果除法溢出，返回Integer.MAX_VALUE
- 查询过程中，最后一次查找**一定**越过被除数，因此可能越界 

第二种越界的解决方案：

将dividend和divisor转换为**负数**，当 tmp + tmp > 0 时（tmp是函数中表示当前查找使用的除数的变量），查找越界。

为什么这样做能解决溢出问题呢？

首先需要明确，采用指数方式查找最终解，最后一次的查找是越过dividend的，因此最后一次查找存在越界的可能。

如果发生越界，则有 tmp + tmp 越界，因此加入判断条件 tmp + tmp < 0。

那为什么不全部改为正数进行运算？因为Integer.MIN_VALUE转换成正数会越界的

**2020.1.3 update**

这道题我参考答案的时候没有考虑时间复杂度和空间复杂度的问题

第一次循环的次数应该是 T =  log_2  (|dividend| /  |divisor|) （以2为底），worst case下第二次是 log_2  (dividend /  |divisor|) - 1...   因此总的时间复杂度应该是T^2级别？

例如：求2047除以2时，假设times()表示该操作需要循环次数 times(2047/2)  ->  10 + times(1023/2) -> ...

本质问题在于没有把中间结果保存下来，因此可以考虑用额外空间换时间，这样下来时间和空间都是O(T)

不过如果要用额外空间的话，查询过程中也不能顺序查找吧...这样反而太曲折了，不如原答案来得直白

------

50-Pow(x, n)

重点：快速幂算法，递归，迭代

递归：把求x的n次幂转换为求x的n/2次幂问题

迭代：借助二进制表示n，从而迭代计算

时间复杂度：O(log N) - both

空间复杂度：O(log N) - 递归（栈空间）  /  O(1) - 迭代

------

166-分数到小数

重点：代码规范，哈希表

实现长除法，注意代码细节及各种边界情况：被除数为0、有负数、无小数部分、越界、小数部分存在循环

使用哈希表存储每个余数对应的“出现位置”，更准确说是将来要被左括号插入的位置

使用Math.abs()转换Integer.MIN_VALUE的时候，要先加上Long.valueOf()，否则Math.abs()根据参数本身的类型推断返回结果类型可能出错

------

168-Excel表列名称

重点：取余

有一个关键的地方：1-26表示A-Z，然而如果直接除以26取余，Z会成为特例，因此先减1然后取余

------

98-验证二叉搜索树

重点：二叉树的遍历

中序遍历，如果本次得到的值小于等于上一个值，则不是二叉搜索树

时间复杂度：O(n)，n为二叉树节点个数，一次遍历每个节点访问一次

空间复杂度：O(n)，worst case下栈中最多需要存储n个节点

------

102-二叉树的层序遍历

重点：二叉树的遍历，层序遍历

时间复杂度：O(n)，n为二叉树节点个数

空间复杂度：O(n)

------

103-二叉树的锯齿形层序遍历

重点：二叉树的遍历，层序遍历

在102的基础上加一个判断顺序的变量，每层改用双端队列

时间复杂度：O(n)，n为二叉树节点个数

空间复杂度：O(n)，渐进复杂度了，并不是太精确感觉（毕竟队列中最多只有两层的节点）

------

#### 105-从前序与中序遍历序列构造二叉树

重点：二叉树的遍历，前序遍历，中序遍历

**递归**的做法比较容易想到，只需要知道前序遍历和中序遍历的特点：

前序遍历：[root，左子树，右子树]

中序遍历：[左子树，root，右子树]

实现细节：用一个哈希表存储每个值在inorder中出现的位置，方便快速查找。

时间复杂度：O(n)，n为二叉树节点个数

空间复杂度：O(n)，哈希表需要O(n)额外空间，递归栈空间O(h)（树深度）小于n，因此总体为O(n)

**迭代**的做法比较取巧

[官方解答](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/)非常详细，值得参考。

我个人理解的大致思路是这样的：

如果存在一棵只有左儿子的树，那么它的前序和中序结果顺序是**完全相反**的，如果在任意位置插入一个右儿子，对于前序遍历：右儿子在尾部。对于中序遍历：右儿子在**其父节点右边**。从这样一个性质中我们有这样的启发：

遍历前序结果，在出现与中序起点相同的结果后，代表这个一直向左的分支走到了尽头。接下来只需要找下一个节点是哪一个节点的右儿子：方法是使用栈存储前序遍历之前的所有结果，不断推出栈内元素的过程应该一直与中序遍历相同，出现不同的时候就是右儿子应该被插入的位置。

时间复杂度：O(n)，n为二叉树节点个数

空间复杂度：O(n)，最多有n个元素被推入栈中

------

106-从中序与后序遍历序列构造二叉树

重点：二叉树的遍历，中序遍历，后序遍历

**递归**的做法和q105略有不同。从后序遍历的尾部向前查询，只需要不断将postorderIndex减1，并先生成右子树，再生成左子树即可。（但完全按照q105的思路应该也能做？）

**迭代**的做法和q105思想基本相同。只不过要从后往前迭代。

时间复杂度：O(n)，两种做法都是O(n)复杂度

空间复杂度：O(n)

------

113-路径总和 II

重点：深度优先搜索，广度优先搜索

注意：DFS写简洁一点，java实现每次添加结果时要使用new关键字，回溯时记得删除操作

时间复杂度：O(n)，n为节点个数（虽然官方解答是n^2，但我更倾向于认同：每个节点只被增删一次）

空间复杂度：O(n)，取决于栈空间深度，最多不超过n

------

114-二叉树展开为链表

重点：二叉树

解决本题的关键在于理解二叉树是如何展开的：左子树最右最下的叶节点是右子树的父节点。然后根据这一点不断将左子树置空即可。

时间复杂度：O(n)，我认为worst case是一棵只有左儿子的二叉树，需要O(n)的移动操作次数

空间复杂度：O(1)，毕竟作为原地算法也不需要什么额外空间

------

116-填充每个节点的下一个右侧节点指针

重点：广度优先搜索，迭代

**BFS**的解法非常直观、简单，但空间复杂度不足（P.S.：层次遍历的重点在于用一个size变量记录本层有多少个节点）

时间复杂度：O(n)，每个节点存取一次

空间复杂度：O(n)，取决于队列需要的空间大小。完美二叉树最后一层有n/2个节点

第二种解法更好：通过上一层已建立的next指针，不断向右迭代构造新的next指针。这样做的理由在于，构造next指针其实只有两种情况：

- 同一个父节点下的左儿子通过next连接右儿子，即 node.left.next = node.right
- 节点的右儿子通过next连接该节点的next节点的左儿子，即 node.right.next = node.next.left

时间复杂度：O(n)，每个节点都会被遍历一次

空间复杂度：O(1)

------

117-填充每个节点的下一个右侧节点指针 II

重点：广度优先搜索，双指针

BFS和q116基本相同。

迭代的解法本质上是**双指针**，由于题目条件不再是完美二叉树，我们需要维护一个指示下一层的nextStart指针，以及一个指示本层前一个节点的last指针。

时间复杂度：O(n)

空间复杂度：O(1)

------

129-求根到叶子节点数字之和

重点：深度优先搜索

简单的DFS。（P.S.：这种问题就没必要搞回溯了）

时间复杂度：O(n)，每个节点访问一次

空间复杂度：O(n)，取决于栈空间深度，即二叉树深度，worst case二叉树深度为n

------

144-二叉树的前序遍历

重点：二叉树，前序遍历

**递归**的解法非常简单。

**迭代**的解法我目前看到了两个版本：

- 第一种是每次从栈中取出一个节点后，先后push右儿子和左儿子
- 第二种是每取得一个节点，一直向左走，将路径上的儿子全部push入栈，取出一个后再向右走（具体看代码就明白了）

Morris遍历之后有空的话可以看一下。

时间复杂度：O(n)，递归和迭代都是

空间复杂度：O(n)，递归和迭代都是

------

145-二叉树的后序遍历

重点：二叉树，后序遍历

**递归**略。

**迭代**的解法：使用一个prev指针指示是否已经遍历当前节点的所有左儿子和右儿子

时间复杂度：O(n)，递归和迭代都是

空间复杂度：O(n)，递归和迭代都是

------

173-二叉搜索树迭代器

重点：迭代器，二叉树，中序遍历

*题目要求：next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。*

从小到大遍历一个二叉搜索树，应该立刻想到**中序遍历**

**递归**解法就是额外创建一个List存储中序遍历结果，供next()调用就可以了

**迭代**解法就是额外创建一个栈，在调用next()时不光要返回数值，还要将当前节点右儿子及其所有左儿子一并推入栈中

时间复杂度：next() -- 递归解法O(1) / 迭代解法worst caseO(n)，均摊O(1)；hasNext() -- 均为O(1)

空间复杂度：递归解法O(n)额外空间 / 迭代解法O(h)，取决于BST高度

------

199-二叉树的右视图

重点：深度优先搜索，广度优先搜索

BFS解法非常容易想到。

DFS解法就是按照先右子树后左子树的方法搜索，加一个判断：当前深度是否初次到达，如果是初次到达那么此时的节点就是本层最右节点。

时间复杂度：O(n)，both

空间复杂度：O(n)，both

------

222-完全二叉树的节点个数

重点：二分查找，位运算

深度优先搜索显然没有利用完全二叉树的性质。

假设root在第0层，最深层为h。那么完全二叉树的节点范围在[2^h, 2^(h+1)-1]。只需要在这个范围内二分查找即可。

那么对于一个固定的值k，怎么知道第k个节点存不存在？使用Huffman树的特点，取得k的二进制表示，从高位到低位，除去最高位恒为1以外，0向左走，1向右走

注意：二分查找还是不熟练，条件为low < high时，取mid时需要向右取整，否则不收敛

注意：位运算优先级低于加减法，记得打括号

注意：root为第0层，不是第1层

时间复杂度：O(log2(n))，n为二叉树节点个数

空间复杂度：O(1)

------

226-翻转二叉树

重点：递归

时间复杂度：O(n)

空间复杂度：O(n)

------

230-二叉搜索树中第K小的元素

重点：中序遍历

时间复杂度：O(n)

空间复杂度：O(n)

------

235-二叉搜索树的最近公共祖先

重点：二叉搜索树

比较root、p、q储存的值，若root值在二者之间则root即为结果，否则向左或向右继续查找。

另一种做法：两次遍历，得到两条路径，找到路径最后一个相同的节点。

时间复杂度：O(n)

空间复杂度：O(1)，如果用两次遍历的做法就是O(n)（不划算）

------

236-二叉树的最近公共祖先

重点：递归，深度优先搜索

暴力一点的解法：DFS找到p和q的路径，比对路径

温和一点的解法：和q235思路相同，只不过需要用一个返回boolean的DFS判断root是否在p、q之间

温和解法中，有两种情况root为结果（本质就是q235）

- p和q一个在root的左子树，一个在root的右子树

- p和q一个就是root，另一个在root的子树中（左右均可）

官方解法中还有一个思路：用一个哈希表存储 所有节点 -> 父节点 的映射关系，不断向上查找获得路径，但我觉得和DFS暴力解法思路有较为相似之处：都是获得p和q的路径。

时间复杂度：O(n)，DFS遍历每个节点一次

空间复杂度：O(n)，DFS的worst case栈空间O(n)。暴力解法需要存储路径，在常系数上比温和解法差

------

109-有序链表转换二叉搜索树

重点：分治，快慢指针，中序遍历

要构建高度平衡的BST，取链表中点作为root，左侧构建左子树，右侧构建右子树，这就形成了一个分治问题。

接下来的问题无非是如何取得链表中点：

- 解法1：快慢指针，O(n)复杂度
- 解法2：利用中序遍历特点，先生成左子树，然后是root，最后生成右子树，那么生成的root顺序一定和链表顺序是相同的，O(1)复杂度

时间复杂度：

- 解法1：递推公式 T(n) = 2 T(n/2) + O(n)，解得O(nlog(n))（计算方法：两边同时除以n）
- 解法2：递推公式 T(n) = 2 T(n/2) + O(1)，解得O(n)

空间复杂度：O(log n)，递归栈空间

------

130-被围绕的区域

重点：深度优先搜索，广度优先搜索

思路：从边界开始搜索，搜索得到的O点一定没有被围绕。使用额外的标记A代替O标记未被围绕的元素。

~~BFS本质就是把DFS的栈空间实现。~~（修正之前的错误理解...怎么可能一样呢）

注意：Java创建新的数组对象要用new，这一点BFS会用到

时间复杂度：O(hw)，h为矩阵高，w为矩阵宽

空间复杂度：O(hw)

------

131-分割回文串

重点：深度优先搜索，回溯

思路：每次截取一个回文串（通过循环及判断找出），然后继续向后搜索，到达末尾后进行回溯。

题解的作者用了一个动态规划去判断回文串

时间复杂度：存疑，之后可以分析一下

空间复杂度：递归栈深度最大为O(N)，N为字符串长度。如果使用动态规划去判断回文串那就用了O(N^2)额外空间

------

133-克隆图

重点：深度优先搜索，广度优先搜索

使用一个哈希表记录当前节点是否被访问过，如果已经访问过则返回哈希表存储结果。

时间复杂度：O(n)，其中n为图中节点个数

空间复杂度：O(n)

------

200-岛屿数量

重点：深度优先搜索，广度优先搜索

本质上就是先循环遍历网格中所有点，发现陆地（标记为1的点）则找出所有与该点连通的点并置0。

时间复杂度：O(mn)

空间复杂度：O(mn)（DFS） 、  O(min(m, n)) （BFS）

------

995-K连续位的最小翻转次数

重点：贪心算法，差分数组，滑动窗口

这道题的本质是贪心算法，我们从数组的头部向尾部遍历，每次遇到0就进行翻转，这样得到的解正是最优解。

但是如果暴力解决，即真的对数组元素进行翻转，那么时间复杂度会达到O(NK)，这是不能接受的。

- 解法1：使用差分数组diff

用一个revCnt变量，储存当前需要匹配的数字（初始为0）。试想一下，如果我们在某一点处匹配了0，即需要在此处进行翻转，那么接下来的点则应该匹配1进行翻转。

但是一个K连续位的翻转只应该作用在[i, i + K - 1]的范围内。到i + K处就失效了，因此应该令diff[i + K]取反（注：指literally取反，不是~代表的按位取反）。这样的话，运行到i + K处的时候，revCnt ^= diff[i + K]，就可以正确得到当前位置需要匹配的值。

*以上是我个人的理解，下面尝试按照差分数组的思想来解释：*

按照官方题解的思路，差分数组diff是对于当前位置元素翻转次数的差分，因此对[i, i + K - 1]进行翻转的时候，只有diff[i]和diff[i+K]需要修改。

revCnt表示累加差分数组得到的当前位置需要翻转的次数。

对diff[i]的修改体现在revCnt ^= 1.

对diff[i + K]修改则是直接diff[i + K] ^= 1，再通过revCnt ^= diff[i]即是一个求和的步骤。

而当i + K > n时，无法执行翻转操作，返回-1

- 解法2：滑动窗口，改进空间复杂度

在解法1中我们使用了差分数组，需要额外的O(N)空间。而如果直接在原数组上进行修改，则可以优化空间复杂度。做法则是对A[i] += 2记录i处发生翻转，revCnt ^= diff[i]的步骤变成查询A[i - K]是否大于1

时间复杂度：暴力解法O(NK)，解法1和解法2 O(N)

空间复杂度：暴力解法O(1)，解法1 O(N)，解法2 O(1)

------

1004-最大连续1的个数 III

重点：滑动窗口

具体做法是，把现在的问题明确为：寻找一个最长的子数组，其中最多有K个元素为0。

因此解法1中，在移动左右端点时，我们同时维护一个lsum和一个rsum，用来储存从头部到左端点以及右端点的0的个数。两者差小于等于K时满足条件。

*在此加入 [@负雪明烛](https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/) 分享的滑动窗口问题的解法思路以及模板如下：*

滑动窗口中用到了左右两个指针，它们移动的思路是：**以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。**

模板如下：

```python
def findSubArray(nums):
    N = len(nums) # 数组/字符串长度
    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
    while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1) # 需要更新结果
        right += 1 # 移动右指针，去探索新的区间
    return res
```



解法2则更加巧妙（原答的写法也确实简洁不太易懂）。维护的是一个**单调递增**的窗口，把K视作可以分配的资源。

- 当K >= 0时，窗口右端点向右前进。
- 当K < 0时，窗口左右端点同时向右前进，即平移窗口。

在上述过程中，如果右端点向右的过程中遇到0，则消耗K。如果左端点向右的过程中经过一个0，则返还K。

时间复杂度：O(N)

空间复杂度：O(1)

------

697-数组的度

重点：哈希表，滑动窗口

解法1，哈希表思路：用哈希表存储每个数出现的次数、第一次出现位置、最后一次出现位置，最终遍历哈希表求解。

解法2，滑动窗口思路：第一次遍历获得最大频数，第二次遍历使用一个新的数组重新计数：

- 当前右端点的值的计数 < 最大频数，则右端点向右扩充
- 当前右端点的值的计数 = 最大频数，则左端点向右收缩，直至当前右端点计数 < 最大频数

时间复杂度：O(N)，其中N为整数数组长度。两种解法都需要遍历数组，解法1和解法2都需要两次遍历（解法1可以优化到只1次遍历）。

空间复杂度：O(N)，但观察代码可知解法2相对需要的额外空间更少，效率也更高。

------

1438-绝对差不超过限制的最长连续子数组

重点：滑动窗口，有序集，单调队列

本题很容易想到滑动窗口算法，但问题在于怎样维护当前子数组中的最大值和最小值。如果每次都循环去寻找最大值和最小值的话，显然效率十分低下。因此有两种解法：

- 使用有序集合存储当前子数组中的元素，平衡树 - 例如Java中的TreeMap（底层实现为红黑树）

- 使用两个单调队列，一个存储最大值，一个存储最小值。这里我一开始看的时候没明白为什么在插入队列中时可以将当前元素后面的元素全部删掉。但仔细一想就会明白，当前元素后面的元素必定会先出队列，因此已经不再起作用了

时间复杂度：O(nlog n) - 解法1（树每次插入元素需要log n时间） /   O(n) - 解法2

空间复杂度：O(n)，两种解法都是O(n)

------

766-托普利茨矩阵

重点：遍历

思路：遍历除了矩阵第一行和第一列外的所有元素，每个元素和自己左上方的元素比较

时间复杂度：O(mn)，其中m和n为矩阵的行数和列数

空间复杂度：O(1)

------

1052-爱生气的书店老板

重点：滑动窗口

先求不使用技能的满意顾客数，再使用滑动窗口求最大值

时间复杂度：O(n)，其中n为店老板工作时间，即数组长度

空间复杂度：O(1)

------

832-翻转图像

重点：双指针

本题唯一要点就是：不需要完全按照先翻转后反转来实现。考虑左右不同时，水平翻转再反转相当于不变。而左右相同时，只需要各自反转即可。

时间复杂度：O(n^2)

空间复杂度：O(1)

------

867-转置矩阵

重点：数学

没什么好说的，注意行和列长度不一定相等就行。

时间复杂度：O(mn)，m和n分别为行和列长度

空间复杂度：O(1)，不包括答案矩阵需要的空间

------

99-恢复二叉搜索树

重点：中序遍历，深度优先搜索（次要）

由于中序遍历是有序的，因此寻找中序遍历中出现的逆序情况，就可以找出错误的节点。

逆序情况会出现1到2次（如果两个错误节点在中序上相邻则1次，否则2次）。

- 解法1：使用列表存储中序遍历结果，遍历列表找出错误节点的值，通过值搜索错误节点

- 解法2：在中序遍历的过程中直接比较上一个节点和当前节点值（相比解法1优化时间复杂度常数项以及空间复杂度）

**解法3：Morris遍历（待补充）**

时间复杂度：解法1和解法2都是 O(n)，相比之下解法1常数项更优

空间复杂度：解法1 - O(n)，解法2 - O(n) worst case / O(h) general case

------

1178-猜字谜

重点：位运算，二进制状态压缩

我们使用长度为26的二进制数来表示word和puzzle

通过遍历words获得二进制数的计数哈希表（筛除长度大于puzzle的词），然后遍历puzzles，每一个puzzle使用其后六个字母的二进制前面加上一个1（必须匹配首字母）来表示。

对于每个puzzle，需要枚举其后六位的子集来确定所有可能的情况。

时间复杂度：O(m|w| + n2^|p|)，其中m和n分别是数组words和puzzles的长度

空间复杂度：O(m)

------

395-至少有K个重复字符的最长子串

重点：分治

- 解法1：分治

对于一个字符串s，如果其中某个字符ch的频率小于k，那么所有包含ch的子串都不可能是结果。因此，ch就起到了划分字符串的作用。

接下来，我们继续在划分后的字符串中重复上一步，直到找不到可划分的字符，就可以得到一个可能的结果（需要比较所有满足条件的子串的长度并求最大）。

时间复杂度：O(N * 26)，每次递归会忽略掉一个用于分割的字符，因此最多递归26层。第一层遍历N次，其他对应层遍历次数之和的上界为N。

空间复杂度：O(26^2)，递归深度为O(26)，每层递归需要开辟O(26)额外空间。（注：因为这里只有小写字母，所以字符集长度为26，否则此处及以上的26需要替换为字符集长度）

- 解法2：滑动窗口

做法是：枚举最长子串中的字符种类数量，本题中为[1, 26]，对于每个字符种类数量，滑动窗口维护的正是这个值，在这个过程中统计当前窗口中不满足条件（频率在(0,k)之间）的字符种类数量。当不满足条件的种类为0时，可以将当前窗口长度与已记录的最长窗口长度进行比较。

时间复杂度：O(26 * N + 26 * 26)，官方解答中说后面的 26 x 26 是初始化计数数组时的复杂度，但似乎解法1的复杂度计算的时候没有统计这一复杂度？

空间复杂度：O(26)

------

896-单调数列

重点：遍历

一次遍历即可解决问题：巧妙利用或运算

时间复杂度：O(n)

空间复杂度：O(1)

------

303-区域和检索 - 数组不可变

重点：前缀和，动态规划

如果每次调用sumRange时通过循环计算区域和的话，复杂度太高，是O(j - i)

因此寻找O(1)时间的解：储存数组的前缀和

实现细节：前缀和长度为 n + 1 （sums[i] 是从索引0到i-1的和）

时间复杂度：初始化O(n)，检索O(1)

空间复杂度：O(n)

------

124-二叉树中的最大路径和

重点：深度优先搜索，递归

一条路径一定有一个顶点。以某个节点为顶点的最大路径和就是 它向左的最长单向路径和 加上 它向右的最长单向路径和。

因此引入一个计算贡献值的函数，贡献值就是当前节点为起点向左的单向路径和向右的单向路径比较后的最大值。

所谓最大路径和就是左右子节点贡献值之和加上当前节点的值。

在这个过程中维护全局的最大路径和。

时间复杂度：O(N)

空间复杂度：O(N) - worst case / O(H) - general case

------

207-课程表

重点：图，深度优先搜索，广度优先搜索

标准的图的搜索问题。

**解法1：深度优先搜索**

关键就是判断这个图是不是**有向无环图**。如果存在环的话，就一定无法完成所有课程的学习。

实现细节：

- 使用邻接表edges存储所有课程信息，即完成 先修课 - 所有子课程 的对应。

- 使用visited存储节点状态。0 - 未访问；1 - 正在访问；2 - 已访问（关于图搜索的题目常见套路）

时间复杂度：O(n + m)，其中n为课程数，m为先修课程要求数

空间复杂度：O(n + m)，邻接表和状态数组需要额外空间，递归复杂度O(n)

**解法2：广度优先搜索**

找出所有没有先修课的课程，也就是可以直接学习的课程。

然后找这些课程的子课程，最后看是不是所有课程都可以直接学习。

时间复杂度：O(n + m)

空间复杂度：O(n + m)，邻接表和状态数组需要额外空间，队列最长复杂度O(n)

------

210-课程表 II

重点：图，深度优先搜索，广度优先搜索

参考q207，基本相同。

注意：使用DFS时，结果的存储顺序应该是从后往前。

时间复杂度：O(n + m)

空间复杂度：O(n + m)

------

剑指Offer 03-数组中重复的数字

重点：遍历

用数组、哈希表、集合都可以。

时间复杂度：O(n)

空间复杂度：O(n)

------

剑指Offer 04-二维数组中的查找

重点：线性查找

暴力解法时间复杂度O(mn)不能接受。

从左上方开始查找，无论向右还是向下都是增加。而从左下方或者右上方开始查找，一个方向是增加，另一个方向减少。因此可以在O(m + n)时间解决问题。

时间复杂度：O(m + n)

空间复杂度：O(1)

------

剑指Offer 05-替换空格

重点：遍历

Java使用StringBuilder会比较方便。

时间复杂度：O(n)，遍历字符串s一遍

空间复杂度：O(1)（如果不考虑答案字符串的话）

------

304-二维区域和检索 - 矩阵不可变

重点：前缀和，动态规划

本题是q303的进阶版，因此二维前缀和的解法和q303思路基本相同。同样，实现过程中前缀和数组的两个维度都多留出一位。

主要难点在于正确使用索引。在我的实现中，sum数组的i, j索引代表原矩阵中[0, i - 1] x [0, j - 1] 的前缀和。

时间复杂度：初始化O(mn)，检索O(1)

空间复杂度：O(mn)

------

338-比特位计数

重点：动态规划，位运算

本题仔细观察的话，可以找出规律，写出O(n)时间的解答不难。以下是三种动态规划的思路。

动态规划的特点：使用之前计算过的结果得到当前位置的解。

- 思路1：计算当前的数与 小于当前数的最大2的幂 的差。以8为例，二进制表示是1 0 0 0，那么从8到15的过程中，最高位始终是1，只有后三位从0 0 0到1 1 1在变化，这就是为什么会有 `bits[i] = 1 + bits[i - highBit]`

- 思路2：i >> 1会把最右边一位去掉，i >> 1之前已经计算过。只需要判断当前 i 的最后一位是1还是0就行（可以使用 i & 1），因此有`bits[i] = bits[i >> 1] + 1`

- 思路3：i & (i - 1)可以去掉 i 最右边的一个1，并且 i & (i - 1)一定小于 i，因此有 `bits[i] = bits[i & (i - 1)] + 1`

时间复杂度：O(n)

空间复杂度：O(1)

------

剑指Offer 06-从尾到头打印链表

重点：栈，递归

实现细节：Java的Stack.toArray()是按push顺序输出的，还是要用一个循环把Stack中元素取出。

时间复杂度：O(n)

空间复杂度：O(n)，遍历链表两遍的做法可以把空间优化到O(1)

------

剑指Offer 07-重建二叉树

本题和[q105](#105-从前序与中序遍历序列构造二叉树)完全相同，递归和迭代两种解法均可参考该处笔记。

------

#### 300-最长递增子序列

重点：动态规划，贪心，二分查找

- 解法1：dp[i]维护前 i 个元素中，以第 i 个元素结尾的最长递增子序列

动态规划方程为：dp[i] = max(d[j]) + 1   (j < i 并且 nums[i] > nums[j])。最终动态规划数组中的最大值就是结果。

时间复杂度：O(n^2)

空间复杂度：O(n)

- 解法2：贪心算法。维护的数组 d 是最终的最长递增子序列。每次考虑一个新的元素时，我们希望序列**上升得尽可能慢**。

因此，当新的元素大于当前数组 d 最后一个元素是，新元素添加至末尾；否则，使用二分查找寻找 d[i - 1] < nums[j] < d[i]，并更新 d[i] = nums[j]

时间复杂度：O(n log n)

空间复杂度：O(n)

------

354-俄罗斯套娃信封问题

重点：动态规划，贪心，二分查找

由于信封具有w和h两个维度，我们对其中一维进行排序后，对另一维进行判断。此时问题转化为一维的求最长递增子序列问题，即[q300](#300-最长递增子序列)。

注意，当第一维出现相等的情况时，例如[1, 1]和[1, 2]，如果我们只判断第二维，会得到错误的结果。解决方法是：第一维升序排列，出现相等情况时按第二维降序排列。经过降序处理后，即使第一维相同，在这些相同的信封中也只有一个会被纳入结果中。

其余部分与[q300](#300-最长递增子序列)基本相同，个人觉得本题的二分查找写法相对后者更清晰，但本质上都一样。

时间复杂度：解法1 - O(n ^ 2)；解法2 - O(n log n)

空间复杂度：O(n)

------

#### 232-用栈实现队列

重点：栈

由于栈的后进先出特性，相当于使原来数据的顺序颠倒。那么数据连续经过两个栈，即可还原其顺序，得到我们需要的队列。

时间复杂度：`push`和`empty`复杂度O(1)，`peek`和`pop`均摊O(1)（每个元素至多入栈出栈两次）

空间复杂度：O(n)

------

剑指Offer 09-用两个栈实现队列

重点：栈

参见[q232](#232-用栈实现队列)，注意数据从输入栈转移到输出栈的时机（输出栈为空）。

------

剑指Offer 10-I-斐波那契数列

重点：动态规划

DP入门题目。（注意这道题需要取模）

------

剑指Offer 10-II-青蛙跳台阶问题

重点：动态规划

DP入门题目。

------

503-下一个更大元素 II

重点：栈，单调栈

维护一个**单调栈**，所谓单调栈，比较形象的理解就是一个Hanoi塔，越靠近栈顶的元素越小。引入一个新的元素时，将所有比这个元素小的元素从栈内弹出，此时当前元素就是这些被弹出元素的下一个更大元素（因为直到遇到当前元素之前，这些被弹出元素后面入栈的元素都小于这些被弹出元素）。

实现细节：栈内存储下标，为了寻找最后一个元素的下一个更大元素，遍历时候复制数组的前n - 1个元素到后面（可以通过下标取模实现）

时间复杂度：O(n)

空间复杂度：worst case下，原数组降序，栈内最多会存储n个元素