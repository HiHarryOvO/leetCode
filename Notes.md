15-三数之和

如果直接三重循环，O(n^3)不可取。双指针方法通常能够降低时间复杂度，如O(n^2) -> O(n)。

注意：遇到相同的元素需要跳过，否则会引入重复的情况。

哈希法空间复杂度可能过高了。

时间复杂度：O(N^2)（排序占用了O(NlogN)），空间复杂度：O(log N)-修改原数组  O(N)-创建新数组

------

16-最接近的三数之和

同样使用双指针，区别在于：每次判断current result和target的位置关系，对应移动second**或**third。

注意：这个answer初始化要看定义的target范围。

时间复杂度：O(N^2)（排序占用了O(NlogN)），空间复杂度：O(log N)-修改原数组  O(N)-创建新数组

------

18-四数之和

双指针，二重循环+双指针。

二重循环中加入极端位置的判断，可减少循环次数。

判断current result和target的位置关系，对应移动最后两个指针。

时间复杂度：O(N^3) (优于O(N^4))

------

31-下一个排列

本题的重点是找出本排列到下一个排列的规律

从左到右找到最后一个相邻升序对(left, right)，最后一个相邻升序对的右侧为单调递减，最小值（**若左右相等，取右边**）与left进行比较，若大于left，则更新right值。

注：为什么要找右侧为单调递减呢？因为单调递减意味着是这一个子序列的最后一个排列情况。设想一个特殊情形：整个序列是逆序的，那么下一个排列就是从头开始的顺序排列。

确定left和right之后，交换对应位置的值，然后对left右侧（单调递减）进行逆序操作（单调递增）

注意：标粗的地方即代码中line 24，e.g. 寻找1,3,3的下一个排列时，1先和后面的3交换，而不是前面的3，然后再做逆序

P.S.：Java中Arrays没有定义reverse()方法，需要自己写

P.S.：一开始自己写的时候用的是Arrays.sort(int[] a, int fromIndex, int toIndex)，时间复杂度不如arrayReverse()操作，并且注意toIndex是不被包括进去的，类似python的range()

时间复杂度：O(N)，空间复杂度：O(1)

------

33-搜索旋转排序数组

核心思想：将数组一分为二，则其中一部分包含旋转点，另一部分不包含。即一部分有序，一部分无序。

通过有序部分的两个端点判断target在哪里，从而确定下一步查找的范围。

注意：寻找旋转点不可取，时间复杂度O(N)。

P.S.：好好练练二分查找的熟练度吧2333

时间复杂度：O(logN)

------

34-在排序数组中查找元素的第一个和最后一个位置

两种实现思路：

- (a) 当产生匹配时，并不结束查找，而是分头向两边寻找是否有比mid更宽的边界
- (b) 首先查找左边界，然后查找右边界

代码细节：

(b)方法写起来更为简洁，但注意求出左边界后要判断左边界是否合法，以及求出右边界需要减1的细节。

时间复杂度：O(logN)

------

39-组合总和

要点：搜索回溯算法，深度优先搜索

深度优先搜索本质是一个递归的过程，回溯部分需要调用递归函数的后面（remove部分）

问题：对原列表排序能否提高效率？应该升序排列还是降序排列？

时间复杂度：O(S)，S为所有可行解长度（但实际上运行过程中还会经历一些不可行的解？e.g.  [2,6,7]  target = 7，那么[2,2,2]会出现在遍历过程中，但实际并不成立）。因此，感觉写成 O(搜索树深度) 更精确，但不够S清晰。

空间复杂度：O(target)，最坏情况1,1,...,1

------

40-组合总和 II

要点：搜索回溯算法，深度优先搜索，39的进阶

与q39最大的不同：如何处理有重复元素的情况？使用q39的方法会导致出现重复结果

解决方案：对原数据排序后，构造一个 <数据 : 频率> 的“字典”（注：对顺序有要求，因此HashMap不可取），对这个字典进行迭代而不是原列表，从而规避重复元素。

在dfs的实现过程中，找出当前元素最多能使用的次数，进行迭代。

注意：dfs的搜索成功判断要放在终止条件前，否则搜索结果不会被加入最终输出（只剩几个空括号......）

时间复杂度：O(N * 2^N)（N为数组长度，一个非常松的上界），最坏的情况下，所有数都不同，且所有数的和小于target，那么所有情况都会被遍历到（早期终止条件不会成立）。最坏情况下，排序时间O(NlogN)可忽略不计。

空间复杂度：O(N)（使用了额外的字典）

------

48-旋转图像

重点：先转置，然后左右翻转

时间复杂度：O(N^2)（以转置为例，交换操作要进行(N^2-N)/2次）

空间复杂度：O(1)

------

54-螺旋矩阵

重点：一圈一圈的迭代，只需不断缩小边界即可。注意边界条件。