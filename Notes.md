15-三数之和

如果直接三重循环，O(n^3)不可取。双指针方法通常能够降低时间复杂度，如O(n^2) -> O(n)。

注意：遇到相同的元素需要跳过，否则会引入重复的情况。

哈希法空间复杂度可能过高了。

时间复杂度：O(N^2)（排序占用了O(NlogN)），空间复杂度：O(log N)-修改原数组  O(N)-创建新数组

------

16-最接近的三数之和

同样使用双指针，区别在于：每次判断current result和target的位置关系，对应移动second**或**third。

注意：这个answer初始化要看定义的target范围。

时间复杂度：O(N^2)（排序占用了O(NlogN)），空间复杂度：O(log N)-修改原数组  O(N)-创建新数组

------

18-四数之和

双指针，二重循环+双指针。

二重循环中加入极端位置的判断，可减少循环次数。

判断current result和target的位置关系，对应移动最后两个指针。

时间复杂度：O(N^3) (优于O(N^4))

------

31-下一个排列

本题的重点是找出本排列到下一个排列的规律

从左到右找到最后一个相邻升序对(left, right)，最后一个相邻升序对的右侧为单调递减，最小值（**若左右相等，取右边**）与left进行比较，若大于left，则更新right值。

注：为什么要找右侧为单调递减呢？因为单调递减意味着是这一个子序列的最后一个排列情况。设想一个特殊情形：整个序列是逆序的，那么下一个排列就是从头开始的顺序排列。

确定left和right之后，交换对应位置的值，然后对left右侧（单调递减）进行逆序操作（单调递增）

注意：标粗的地方即代码中line 24，e.g. 寻找1,3,3的下一个排列时，1先和后面的3交换，而不是前面的3，然后再做逆序

P.S.：Java中Arrays没有定义reverse()方法，需要自己写

P.S.：一开始自己写的时候用的是Arrays.sort(int[] a, int fromIndex, int toIndex)，时间复杂度不如arrayReverse()操作，并且注意toIndex是不被包括进去的，类似python的range()

时间复杂度：O(N)，空间复杂度：O(1)

------

33-搜索旋转排序数组

核心思想：将数组一分为二，则其中一部分包含旋转点，另一部分不包含。即一部分有序，一部分无序。

通过有序部分的两个端点判断target在哪里，从而确定下一步查找的范围。

注意：寻找旋转点不可取，时间复杂度O(N)。

P.S.：好好练练二分查找的熟练度吧2333

时间复杂度：O(logN)

------

34-在排序数组中查找元素的第一个和最后一个位置

两种实现思路：

- (a) 当产生匹配时，并不结束查找，而是分头向两边寻找是否有比mid更宽的边界
- (b) 首先查找左边界，然后查找右边界

代码细节：

(b)方法写起来更为简洁，但注意求出左边界后要判断左边界是否合法，以及求出右边界需要减1的细节。

时间复杂度：O(logN)

------

39-组合总和

要点：搜索回溯算法，深度优先搜索

深度优先搜索本质是一个递归的过程，回溯部分需要调用递归函数的后面（remove部分）

问题：对原列表排序能否提高效率？应该升序排列还是降序排列？

时间复杂度：O(S)，S为所有可行解长度（但实际上运行过程中还会经历一些不可行的解？e.g.  [2,6,7]  target = 7，那么[2,2,2]会出现在遍历过程中，但实际并不成立）。因此，感觉写成 O(搜索树深度) 更精确，但不够S清晰。

空间复杂度：O(target)，最坏情况1,1,...,1

------

40-组合总和 II

要点：搜索回溯算法，深度优先搜索，39的进阶

与q39最大的不同：如何处理有重复元素的情况？使用q39的方法会导致出现重复结果

解决方案：对原数据排序后，构造一个 <数据 : 频率> 的“字典”（注：对顺序有要求，因此HashMap不可取），对这个字典进行迭代而不是原列表，从而规避重复元素。

在dfs的实现过程中，找出当前元素最多能使用的次数，进行迭代。

注意：dfs的搜索成功判断要放在终止条件前，否则搜索结果不会被加入最终输出（只剩几个空括号......）

时间复杂度：O(N * 2^N)（N为数组长度，一个非常松的上界），最坏的情况下，所有数都不同，且所有数的和小于target，那么所有情况都会被遍历到（早期终止条件不会成立）。最坏情况下，排序时间O(NlogN)可忽略不计。

空间复杂度：O(N)（使用了额外的字典）

------

48-旋转图像

重点：先转置，然后左右翻转

时间复杂度：O(N^2)（以转置为例，交换操作要进行(N^2-N)/2次）

空间复杂度：O(1)

------

54-螺旋矩阵

重点：一圈一圈的迭代，只需不断缩小边界即可。注意边界条件。

时间复杂度：O(mn)，即矩阵中每个元素遍历一次

空间复杂度：O(1)

------

55-跳跃游戏

重点：贪心算法，每次记录最远距离，迭代中若index超过最远距离则无法到达

别把这个问题想太复杂。以及要了解贪心算法：

局部最优解能否推出全局最优解？可以的话贪心算法可行，拆分全局的问题为局部问题。

例如：本题中，对于每一个点，我们能够找到**当前**能够到达的最远距离，在这个点到最远距离的所有点中，我们又去找对于每一个点的最远距离，以此更新能到达的最远距离。最终找到全局最远距离。

时间复杂度：O(N)，N为数组长度

空间复杂度：O(1)

------

5-最长回文子串

重点：动态规划

思路：对于一个回文串，判断该串左右字符是否相等，相等的话则回文串增长。

边界情况：奇数字符回文串（aba），边界情况可认为是只有一个字符；偶数字符回文串（abba），边界情况可认为是相邻两个字符相等

实现过程中的一个细节问题：我是直接创建空字符串，然后通过加法不断更新字符串，似乎这样的运行速度有点慢（但也是能通过的）？

时间复杂度：O(N^2)，极端情况下，向两边扩展的次数为0,1,2,...,N/2,...,2,1,0，求和可知是N^2量级

空间复杂度：O(N)，按我的实现方式，每次用当前回文子串和存储的已知最长子串对比，因此只需要O(N)空间即可

------

62-不同路径

重点：数学思路 or 动态规划

数学思路：可以转化为m+n-2个相同单位中抽n-1个的组合数问题

动态规划：每个点的值等于他左边点的值加上他上面点的值，因此，我们每次保存上一行，就可以计算出这一行的所有结果。

注意：使用Java写组合数计算方法，由于题目中m, n取值较大，不能直接计算m+n-2的阶乘，否则会溢出。应该采取别的计算组合数的方法，所以我代码中的是未通过版本。但主要思想到位了就可以，
重点放在动态规划上吧。

（以下复杂度基于动态规划的实现讨论）

时间复杂度：O(mn)，需要遍历每一个点

空间复杂度：O(2n)，只需要储存当前行和上一行就能进行计算了

------

63-不同路径 II

重点：动态规划

和q62的动态规划思路基本完全相同，加入障碍物：某一点存在障碍物时，该点放弃原有赋值方法，直接取0就可以

注意：注意一下几个边界情况（起点存在障碍物，第一行或第一列存在障碍物，只有一行或一列，只有一个点）

时间复杂度：O(mn)，需要遍历每一个点（和q62是相同的）

空间复杂度：O(2n)，只需要储存当前行和上一行就能进行计算了（和q62是相同的）

------

64-最小路径和

重点：动态规划

思路：本题和q62以及q63没有本质区别。想清楚一点：之前两道题都是从左上到右下求解，本题是从右下往左上求解。

动态规划方程：每一个点的最小路径和 = min(右边邻居的最小路径，下面邻居的最小路径) + 本点的值

时间复杂度：O(mn)

空间复杂度：O(2n)

------

91-解码方法

重点：动态规划

动态规划方程：dp[i] = dp[i-1] * I(i处数字不为0) + dp[i-2] * I(i-1和i处的数字组成合法两位数，即在[10,26]区间内)

代码里留了两种主要思想相同的实现方法，第一种的写法更符合我刚开始的思考方式，第二种使用数组解决问题，更加直观。

时间复杂度：O(N)，遍历整个字符串

空间复杂度：O(1)，第一种写法，只记录前两次的计算结果；O(N)，第二种写法，创建一个数组保留每次计算结果

------

95-不同的二叉搜索树 II

重点：递归 or 动态规划

对比之下，递归还是最容易想到的...

动态规划有两种思路：

- (1) 储存所有的解，即dp[0], dp[1],..., dp[n]，对于dp[i]，确定根节点j后，左边即是dp[j-1]，右边是dp[i-j]加上一个偏差之后的结果

这个思路非常巧妙：这个问题的一个trick在于，例如某次分割下右子树中有i-j个连续元素，这i-j个连续元素生成的BST个数和1,2,...,i-j生成的BST个数相同，结构相同，唯一的
区别就是需要在1,2,...,i-j生成的BST上加上一个偏差值

- (2) 储存上一次计算得到的值，插入一个新的最大值，有且仅有这些情况：作为新的根节点 or 作为根节点的右子树根节点 or 根节点的右子树的右子树的根节点 ... and so on

需要找出最多可以向右走多少步，每走一步均可以生成新的结果

时间复杂度：可行BST的个数为Gn，生成一棵BST时间为O(n)，总体时间复杂度为：O(nGn)，Gn即是数学上的卡特兰数，其增长速度为 4^n / (n^(3/2))，故总时间复杂度为O(4^n / (n^(1/2)))

空间复杂度：O(4^n / (n^(1/2)))，与时间复杂度相同，个人理解：由于增长速度过快，递归所需栈空间 and 方法三动态规划省略的前n-1次结果，都可以忽略不计？（并没有严谨考察）

------

96-不同的二叉搜索树

重点：动态规划

弄懂了q95的动态规划思路(1)，这道题就会非常简单。动态规划方程：dp[i] += dp[j-1] * dp[i-j];  (j from 1 to i)

时间复杂度：O(n^2)，查看代码中循环可知

空间复杂度：O(n)，存储动态规划数组

------

120-三角形最小路径和

重点：动态规划

从上到下求解，只需O(n)空间，每次在原数组上更新值即可。

从右往左更新就可以避免覆盖掉所需数值的问题。每一个点的路径来自于上一行下标相同的点或上一行下标-1的点，因此，从右往左更新时，覆盖掉的点不会用于求下一个点的值。

时间复杂度：O(n^2)

空间复杂度：O(n)

------

139-单词拆分

重点：动态规划

动态规划方程：dp[i] = dp[j] && check(s[j,...,i-1]) （每次加入新字符时，判断和之前所有字符组成的划分能不能被字典中的单词拆分）

注意：j（即划分位置）从右往左会减少查找需要的次数

时间复杂度：O(n^2)，对于长度为n的字符串，有n种划分，因此需要运行1,2,...,n次，故为n^2时间

空间复杂度：O(n)，使用了HashSet以及动态规划数组

------

152-乘积最大子数组

重点：动态规划（特殊）

维护**两个**动态规划数组，一个存储当前连续最大值，一个存储当前连续最小值。

每次引入新数字时，对于最大值DP数组存在这样的情况：最大值更大，最小值变为最大，nums[i]单独最大

对于最小值DP数组则是对应的相反的情况

最后比较最大值DP数组中的数值

时间复杂度：O(n)

空间复杂度：O(n)，常系数为2，引入了两个DP数组

------

6-Z字形变换

重点：字符串处理

使用两个循环固然可行，但并不直观。使用一个储存StringBuilder的List，储存每一行的情况。

只需从头遍历到结尾即可把每个字符加到其对应的行中。（使用了一个布尔变量getDown判断是进入下一行还是上一行，在拐角处修改getDown）

标准答案里创建的行数是取numRows和s.length()的最小值，也可直接写numRows，并不是必须。

时间复杂度：O(N)，N为字符串长度，遍历整个字符串

空间复杂度：O(N)

------

8-字符串转换整数 (atoi)

重点：字符串处理，确定有限状态机（DFA）

做题的时候状态好的话，用if-else判断也没有非常臃肿，但要确保自己考虑到了方方面面。但DFA作为一个更条理更清晰的知识，也建议学习一下。

有限状态机：我的理解是，把字符串的遍历过程中的处理方法作为这个字符串的状态，各个状态组成一个有向图，有固定的转换规则，对于同一状态下的
不同字符均可采用同样的处理方式（见get方法），显得更为简洁。

注意：使用long处理结果以防溢出，负数比较的时候是和 - (long) Integer.MIN_VALUE 比较，因为ans是去掉符号后的结果

时间复杂度：O(N)，N为字符串长度，遍历整个字符串

空间复杂度：O(1)，自动机只需O(1)空间

------

12-整数转罗马数字

重点：贪心算法

两种方法：1) 从最大情况到最小情况依次查找并添加结果；2) 硬编码，把每一位上的所有可能情况列出来

时间复杂度：O(1)，由于题目限定数字的取值范围，因此迭代次数上限是可预知的

空间复杂度：O(1)，额外空间长度不随数字改变而改变

------

17-电话号码的字母组合

重点：DFS，回溯

这道题是非常标准的考察DFS + 回溯的题目，需要自己能够快速写出解答，但是要注意一些细节。

注意：可以在method外定义变量，这样dfs方法的参数会少很多，更加简洁。遇到非2-9的字符需要跳过（这一点标答中似乎没有考虑？）。另一个细节问题，
如果在method内定义变量，把定义的哈希表传入dfs的时候，一定要具体写出内部储存元素的类型，否则会报错的。

时间复杂度：O(3^m x 4^n)，其中m为对应3个字母的数字（2,3,4,5,6,8），n为对应4个字母的数字（7,9），也就是可行解的个数（通常情况下的dfs搜索复杂度）

空间复杂度：O(m + n)，不考虑返回值的情况。空间复杂度取决于：递归深度（m + n），以及哈希表存储空间（常数空间）。

------

10-正则表达式匹配

重点：动态规划

想到对string和pattern同时进行动态规划非常重要。匹配到 * 号既可以是dp[i-1][j]，即去除字符串末尾一位后继续匹配，
也可以是dp[i][j-2]，即 * 号前面那个字符匹配了0次。

动态规划方程如下：

![q10](./pics/q10.JPG)

时间复杂度：O(mn)，遍历动态规划数组

空间复杂度：O(mn)

------

22-括号生成

重点：DFS，回溯

同样是非常标准的DFS，实现过程中需要注意的一个原则：在一个结果中，从左到右进行统计时，左括号的数量始终大于等于右括号数量，所以我写的时候
加了left和right两个参数示意待添加的左括号和右括号数量

时间复杂度：卡特兰数增长速度为 4^n / (n^(3/2))，复制每一个可行解到结果中需要O(n)时间，故总时间复杂度为O(4^n / (n^(1/2)))

空间复杂度：取决于递归栈的深度，每一层递归函数需要O(1)的空间，最多递归2n层，因此空间复杂度为 O(n)

------

43-字符串相乘

重点：字符串处理，数学问题

方法1：模拟竖式乘法的过程，num1的整体和num2的每一位相乘，然后结果按规则相加

注意：使用StringBuilder或者StringBuffer，数字可直接使用append()方法，append()方法重载了多次（char, int, long, float...），不需要加48后显式转换

时间复杂度（方法1）：O(mn + n ^ 2)，计算乘法过程中需要O(mn)时间，每次阶段结果相加时，字符串最长为m + n，相加n次，因此加法操作需要O((m + n) x n)时间

空间复杂度（方法1）：O(m + n)，存储的字符串的长度最大为O(m + n)

方法2：创建一个长数组，每次维护数组内的值

首先我们需要知道，m位的数字和n位的数字相乘，结果至多为m + n位，至少为m + n - 1位

步骤：

- 第一个数第i位和第二个数第j位相乘，结果进入长数组的i + j + 1位

- 从后往前维护进位

- 最后，长数组转换为字符串输出

时间复杂度（方法2）：O(mn)，观察上述步骤，相乘过程时间复杂度为O(mn)，维护进位和字符串转换需要O(m + n)

空间复杂度（方法3）：O(m + n)，需要一个长数组

------