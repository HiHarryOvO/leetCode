15-三数之和

如果直接三重循环，O(n^3)不可取。双指针方法通常能够降低时间复杂度，如O(n^2) -> O(n)。

注意：遇到相同的元素需要跳过，否则会引入重复的情况。

哈希法空间复杂度可能过高了。

时间复杂度：O(N^2)（排序占用了O(NlogN)），空间复杂度：O(log N)-修改原数组  O(N)-创建新数组

------

16-最接近的三数之和

同样使用双指针，区别在于：每次判断current result和target的位置关系，对应移动second**或**third。

注意：这个answer初始化要看定义的target范围。

时间复杂度：O(N^2)（排序占用了O(NlogN)），空间复杂度：O(log N)-修改原数组  O(N)-创建新数组

------

18-四数之和

双指针，二重循环+双指针。

二重循环中加入极端位置的判断，可减少循环次数。

判断current result和target的位置关系，对应移动最后两个指针。

时间复杂度：O(N^3) (优于O(N^4))

------

31-下一个排列

本题的重点是找出本排列到下一个排列的规律

从左到右找到最后一个相邻升序对(left, right)，最后一个相邻升序对的右侧为单调递减，最小值（**若左右相等，取右边**）与left进行比较，若大于left，则更新right值。

注：为什么要找右侧为单调递减呢？因为单调递减意味着是这一个子序列的最后一个排列情况。设想一个特殊情形：整个序列是逆序的，那么下一个排列就是从头开始的顺序排列。

确定left和right之后，交换对应位置的值，然后对left右侧（单调递减）进行逆序操作（单调递增）

注意：标粗的地方即代码中line 24，e.g. 寻找1,3,3的下一个排列时，1先和后面的3交换，而不是前面的3，然后再做逆序

P.S.：Java中Arrays没有定义reverse()方法，需要自己写

P.S.：一开始自己写的时候用的是Arrays.sort(int[] a, int fromIndex, int toIndex)，时间复杂度不如arrayReverse()操作，并且注意toIndex是不被包括进去的，类似python的range()

时间复杂度：O(N)，空间复杂度：O(1)

------

33-搜索旋转排序数组

核心思想：将数组一分为二，则其中一部分包含旋转点，另一部分不包含。即一部分有序，一部分无序。

通过有序部分的两个端点判断target在哪里，从而确定下一步查找的范围。

注意：寻找旋转点不可取，时间复杂度O(N)。

P.S.：好好练练二分查找的熟练度吧2333

时间复杂度：O(logN)

------

34-在排序数组中查找元素的第一个和最后一个位置

两种实现思路：

- (a) 当产生匹配时，并不结束查找，而是分头向两边寻找是否有比mid更宽的边界
- (b) 首先查找左边界，然后查找右边界

代码细节：

(b)方法写起来更为简洁，但注意求出左边界后要判断左边界是否合法，以及求出右边界需要减1的细节。

时间复杂度：O(logN)

------

39-组合总和

要点：搜索回溯算法，深度优先搜索

深度优先搜索本质是一个递归的过程，回溯部分需要调用递归函数的后面（remove部分）

问题：对原列表排序能否提高效率？应该升序排列还是降序排列？

时间复杂度：O(S)，S为所有可行解长度（但实际上运行过程中还会经历一些不可行的解？e.g.  [2,6,7]  target = 7，那么[2,2,2]会出现在遍历过程中，但实际并不成立）。因此，感觉写成 O(搜索树深度) 更精确，但不够S清晰。

空间复杂度：O(target)，最坏情况1,1,...,1

------

40-组合总和 II

要点：搜索回溯算法，深度优先搜索，39的进阶

与q39最大的不同：如何处理有重复元素的情况？使用q39的方法会导致出现重复结果

解决方案：对原数据排序后，构造一个 <数据 : 频率> 的“字典”（注：对顺序有要求，因此HashMap不可取），对这个字典进行迭代而不是原列表，从而规避重复元素。

在dfs的实现过程中，找出当前元素最多能使用的次数，进行迭代。

注意：dfs的搜索成功判断要放在终止条件前，否则搜索结果不会被加入最终输出（只剩几个空括号......）

时间复杂度：O(N * 2^N)（N为数组长度，一个非常松的上界），最坏的情况下，所有数都不同，且所有数的和小于target，那么所有情况都会被遍历到（早期终止条件不会成立）。最坏情况下，排序时间O(NlogN)可忽略不计。

空间复杂度：O(N)（使用了额外的字典）

------

48-旋转图像

重点：先转置，然后左右翻转

时间复杂度：O(N^2)（以转置为例，交换操作要进行(N^2-N)/2次）

空间复杂度：O(1)

------

54-螺旋矩阵

重点：一圈一圈的迭代，只需不断缩小边界即可。注意边界条件。

时间复杂度：O(mn)，即矩阵中每个元素遍历一次

空间复杂度：O(1)

------

55-跳跃游戏

重点：贪心算法，每次记录最远距离，迭代中若index超过最远距离则无法到达

别把这个问题想太复杂。以及要了解贪心算法：

局部最优解能否推出全局最优解？可以的话贪心算法可行，拆分全局的问题为局部问题。

例如：本题中，对于每一个点，我们能够找到**当前**能够到达的最远距离，在这个点到最远距离的所有点中，我们又去找对于每一个点的最远距离，以此更新能到达的最远距离。最终找到全局最远距离。

时间复杂度：O(N)，N为数组长度

空间复杂度：O(1)

------

5-最长回文子串

重点：动态规划

思路：对于一个回文串，判断该串左右字符是否相等，相等的话则回文串增长。

边界情况：奇数字符回文串（aba），边界情况可认为是只有一个字符；偶数字符回文串（abba），边界情况可认为是相邻两个字符相等

实现过程中的一个细节问题：我是直接创建空字符串，然后通过加法不断更新字符串，似乎这样的运行速度有点慢（但也是能通过的）？

时间复杂度：O(N^2)，极端情况下，向两边扩展的次数为0,1,2,...,N/2,...,2,1,0，求和可知是N^2量级

空间复杂度：O(N)，按我的实现方式，每次用当前回文子串和存储的已知最长子串对比，因此只需要O(N)空间即可

------

62-不同路径

重点：数学思路 or 动态规划

数学思路：可以转化为m+n-2个相同单位中抽n-1个的组合数问题

动态规划：每个点的值等于他左边点的值加上他上面点的值，因此，我们每次保存上一行，就可以计算出这一行的所有结果。

注意：使用Java写组合数计算方法，由于题目中m, n取值较大，不能直接计算m+n-2的阶乘，否则会溢出。应该采取别的计算组合数的方法，所以我代码中的是未通过版本。但主要思想到位了就可以，
重点放在动态规划上吧。

（以下复杂度基于动态规划的实现讨论）

时间复杂度：O(mn)，需要遍历每一个点

空间复杂度：O(2n)，只需要储存当前行和上一行就能进行计算了

------

63-不同路径 II

重点：动态规划

和q62的动态规划思路基本完全相同，加入障碍物：某一点存在障碍物时，该点放弃原有赋值方法，直接取0就可以

注意：注意一下几个边界情况（起点存在障碍物，第一行或第一列存在障碍物，只有一行或一列，只有一个点）

时间复杂度：O(mn)，需要遍历每一个点（和q62是相同的）

空间复杂度：O(2n)，只需要储存当前行和上一行就能进行计算了（和q62是相同的）

------

64-最小路径和

重点：动态规划

思路：本题和q62以及q63没有本质区别。想清楚一点：之前两道题都是从左上到右下求解，本题是从右下往左上求解。

动态规划方程：每一个点的最小路径和 = min(右边邻居的最小路径，下面邻居的最小路径) + 本点的值

时间复杂度：O(mn)

空间复杂度：O(2n)

------

91-解码方法

重点：动态规划

动态规划方程：dp[i] = dp[i-1] * I(i处数字不为0) + dp[i-2] * I(i-1和i处的数字组成合法两位数，即在[10,26]区间内)

代码里留了两种主要思想相同的实现方法，第一种的写法更符合我刚开始的思考方式，第二种使用数组解决问题，更加直观。

时间复杂度：O(N)，遍历整个字符串

空间复杂度：O(1)，第一种写法，只记录前两次的计算结果；O(N)，第二种写法，创建一个数组保留每次计算结果

------

95-不同的二叉搜索树 II

重点：递归 or 动态规划

对比之下，递归还是最容易想到的...

动态规划有两种思路：

- (1) 储存所有的解，即dp[0], dp[1],..., dp[n]，对于dp[i]，确定根节点j后，左边即是dp[j-1]，右边是dp[i-j]加上一个偏差之后的结果

这个思路非常巧妙：这个问题的一个trick在于，例如某次分割下右子树中有i-j个连续元素，这i-j个连续元素生成的BST个数和1,2,...,i-j生成的BST个数相同，结构相同，唯一的
区别就是需要在1,2,...,i-j生成的BST上加上一个偏差值

- (2) 储存上一次计算得到的值，插入一个新的最大值，有且仅有这些情况：作为新的根节点 or 作为根节点的右子树根节点 or 根节点的右子树的右子树的根节点 ... and so on

需要找出最多可以向右走多少步，每走一步均可以生成新的结果

时间复杂度：可行BST的个数为Gn，生成一棵BST时间为O(n)，总体时间复杂度为：O(nGn)，Gn即是数学上的卡特兰数，其增长速度为 4^n / (n^(3/2))，故总时间复杂度为O(4^n / (n^(1/2)))

空间复杂度：O(4^n / (n^(1/2)))，与时间复杂度相同，个人理解：由于增长速度过快，递归所需栈空间 and 方法三动态规划省略的前n-1次结果，都可以忽略不计？（并没有严谨考察）

------

96-不同的二叉搜索树

重点：动态规划

弄懂了q95的动态规划思路(1)，这道题就会非常简单。动态规划方程：dp[i] += dp[j-1] * dp[i-j];  (j from 1 to i)

时间复杂度：O(n^2)，查看代码中循环可知

空间复杂度：O(n)，存储动态规划数组

------

120-三角形最小路径和

重点：动态规划

从上到下求解，只需O(n)空间，每次在原数组上更新值即可。

从右往左更新就可以避免覆盖掉所需数值的问题。每一个点的路径来自于上一行下标相同的点或上一行下标-1的点，因此，从右往左更新时，覆盖掉的点不会用于求下一个点的值。

时间复杂度：O(n^2)

空间复杂度：O(n)

------

139-单词拆分

重点：动态规划

动态规划方程：dp[i] = dp[j] && check(s[j,...,i-1]) （每次加入新字符时，判断和之前所有字符组成的划分能不能被字典中的单词拆分）

注意：j（即划分位置）从右往左会减少查找需要的次数

时间复杂度：O(n^2)，对于长度为n的字符串，有n种划分，因此需要运行1,2,...,n次，故为n^2时间

空间复杂度：O(n)，使用了HashSet以及动态规划数组

------

152-乘积最大子数组

重点：动态规划（特殊）

维护**两个**动态规划数组，一个存储当前连续最大值，一个存储当前连续最小值。

每次引入新数字时，对于最大值DP数组存在这样的情况：最大值更大，最小值变为最大，nums[i]单独最大

对于最小值DP数组则是对应的相反的情况

最后比较最大值DP数组中的数值

时间复杂度：O(n)

空间复杂度：O(n)，常系数为2，引入了两个DP数组

------

6-Z字形变换

重点：字符串处理

使用两个循环固然可行，但并不直观。使用一个储存StringBuilder的List，储存每一行的情况。

只需从头遍历到结尾即可把每个字符加到其对应的行中。（使用了一个布尔变量getDown判断是进入下一行还是上一行，在拐角处修改getDown）

标准答案里创建的行数是取numRows和s.length()的最小值，也可直接写numRows，并不是必须。

时间复杂度：O(N)，N为字符串长度，遍历整个字符串

空间复杂度：O(N)

------

8-字符串转换整数 (atoi)

重点：字符串处理，确定有限状态机（DFA）

做题的时候状态好的话，用if-else判断也没有非常臃肿，但要确保自己考虑到了方方面面。但DFA作为一个更条理更清晰的知识，也建议学习一下。

有限状态机：我的理解是，把字符串的遍历过程中的处理方法作为这个字符串的状态，各个状态组成一个有向图，有固定的转换规则，对于同一状态下的
不同字符均可采用同样的处理方式（见get方法），显得更为简洁。

注意：使用long处理结果以防溢出，负数比较的时候是和 - (long) Integer.MIN_VALUE 比较，因为ans是去掉符号后的结果

时间复杂度：O(N)，N为字符串长度，遍历整个字符串

空间复杂度：O(1)，自动机只需O(1)空间

------

12-整数转罗马数字

重点：贪心算法

两种方法：1) 从最大情况到最小情况依次查找并添加结果；2) 硬编码，把每一位上的所有可能情况列出来

时间复杂度：O(1)，由于题目限定数字的取值范围，因此迭代次数上限是可预知的

空间复杂度：O(1)，额外空间长度不随数字改变而改变

------

17-电话号码的字母组合

重点：DFS，回溯

这道题是非常标准的考察DFS + 回溯的题目，需要自己能够快速写出解答，但是要注意一些细节。

注意：可以在method外定义变量，这样dfs方法的参数会少很多，更加简洁。遇到非2-9的字符需要跳过（这一点标答中似乎没有考虑？）。另一个细节问题，
如果在method内定义变量，把定义的哈希表传入dfs的时候，一定要具体写出内部储存元素的类型，否则会报错的。

时间复杂度：O(3^m x 4^n)，其中m为对应3个字母的数字（2,3,4,5,6,8），n为对应4个字母的数字（7,9），也就是可行解的个数（通常情况下的dfs搜索复杂度）

空间复杂度：O(m + n)，不考虑返回值的情况。空间复杂度取决于：递归深度（m + n），以及哈希表存储空间（常数空间）。

------

10-正则表达式匹配

重点：动态规划

想到对string和pattern同时进行动态规划非常重要。匹配到 * 号既可以是dp[i-1][j]，即去除字符串末尾一位后继续匹配，
也可以是dp[i][j-2]，即 * 号前面那个字符匹配了0次。

动态规划方程如下：

![q10](./pics/q10.JPG)

时间复杂度：O(mn)，遍历动态规划数组

空间复杂度：O(mn)

------

22-括号生成

重点：DFS，回溯

同样是非常标准的DFS，实现过程中需要注意的一个原则：在一个结果中，从左到右进行统计时，左括号的数量始终大于等于右括号数量，所以我写的时候
加了left和right两个参数示意待添加的左括号和右括号数量

时间复杂度：卡特兰数增长速度为 4^n / (n^(3/2))，复制每一个可行解到结果中需要O(n)时间，故总时间复杂度为O(4^n / (n^(1/2)))

空间复杂度：取决于递归栈的深度，每一层递归函数需要O(1)的空间，最多递归2n层，因此空间复杂度为 O(n)

------

43-字符串相乘

重点：字符串处理，数学问题

方法1：模拟竖式乘法的过程，num1的整体和num2的每一位相乘，然后结果按规则相加

注意：使用StringBuilder或者StringBuffer，数字可直接使用append()方法，append()方法重载了多次（char, int, long, float...），不需要加48后显式转换

时间复杂度（方法1）：O(mn + n ^ 2)，计算乘法过程中需要O(mn)时间，每次阶段结果相加时，字符串最长为m + n，相加n次，因此加法操作需要O((m + n) x n)时间

空间复杂度（方法1）：O(m + n)，存储的字符串的长度最大为O(m + n)

方法2：创建一个长数组，每次维护数组内的值

首先我们需要知道，m位的数字和n位的数字相乘，结果至多为m + n位，至少为m + n - 1位

步骤：

- 第一个数第i位和第二个数第j位相乘，结果进入长数组的i + j + 1位

- 从后往前维护进位

- 最后，长数组转换为字符串输出

时间复杂度（方法2）：O(mn)，观察上述步骤，相乘过程时间复杂度为O(mn)，维护进位和字符串转换需要O(m + n)

空间复杂度（方法3）：O(m + n)，需要一个长数组

------

49-字母异位词分组

重点：哈希表

方法1：每个字符串排序后的结果作为哈希表的key值

方法2：自行构建散列函数，"#2#1...#0"这样的形式

假设字符串数组长度为N，每个字符串长度为K

时间复杂度：O(NKlogK)(方法1)，O(NK)(方法2)，可见排序并不是这个问题中的最优解

空间复杂度：O(NK)

------

71-简化路径

重点：字符串处理，栈和队列

使用字符串的split函数，传入"/"作为参数（注意传入参数必须为字符串）

使用双向队列更容易处理，使用栈亦可。

时间复杂度：O(N)，其中N为最初输入的path长度

空间复杂度：O(N)

------

29-两数相除

重点：32位有符号整数的越界条件判断，指数递增查找，递归

将dividend分别除以divisor的1,2,4,8...倍（可以通过自加运算实现），确定范围后递归查询精确结果

这道题重点在：第一，确定这个**指数递增查找**的思路；第二，判断越界条件。以下重点讲讲越界情况：

- dividend = Integer.MIN_VALUE, divisor = -1    题目条件中说如果除法溢出，返回Integer.MAX_VALUE
- 查询过程中，最后一次查找**一定**越过被除数，因此可能越界 

第二种越界的解决方案：

将dividend和divisor转换为**负数**，当 tmp + tmp > 0 时（tmp是函数中表示当前查找使用的除数的变量），查找越界。

为什么这样做能解决溢出问题呢？

首先需要明确，采用指数方式查找最终解，最后一次的查找是越过dividend的，因此最后一次查找存在越界的可能。

如果发生越界，则有 tmp + tmp 越界，因此加入判断条件 tmp + tmp < 0。

那为什么不全部改为正数进行运算？因为Integer.MIN_VALUE转换成正数会越界的

**2020.1.3 update**

这道题我参考答案的时候没有考虑时间复杂度和空间复杂度的问题

第一次循环的次数应该是 T =  log_2  (|dividend| /  |divisor|) （以2为底），worst case下第二次是 log_2  (dividend /  |divisor|) - 1...   因此总的时间复杂度应该是T^2级别？

例如：求2047除以2时，假设times()表示该操作需要循环次数 times(2047/2)  ->  10 + times(1023/2) -> ...

本质问题在于没有把中间结果保存下来，因此可以考虑用额外空间换时间，这样下来时间和空间都是O(T)

不过如果要用额外空间的话，查询过程中也不能顺序查找吧...这样反而太曲折了，不如原答案来得直白

------

50-Pow(x, n)

重点：快速幂算法，递归，迭代

递归：把求x的n次幂转换为求x的n/2次幂问题

迭代：借助二进制表示n，从而迭代计算

时间复杂度：O(log N) - both

空间复杂度：O(log N) - 递归（栈空间）  /  O(1) - 迭代

------

166-分数到小数

重点：代码规范，哈希表

实现长除法，注意代码细节及各种边界情况：被除数为0、有负数、无小数部分、越界、小数部分存在循环

使用哈希表存储每个余数对应的“出现位置”，更准确说是将来要被左括号插入的位置

使用Math.abs()转换Integer.MIN_VALUE的时候，要先加上Long.valueOf()，否则Math.abs()根据参数本身的类型推断返回结果类型可能出错

------

168-Excel表列名称

重点：取余

有一个关键的地方：1-26表示A-Z，然而如果直接除以26取余，Z会成为特例，因此先减1然后取余

------

98-验证二叉搜索树

重点：二叉树的遍历

中序遍历，如果本次得到的值小于等于上一个值，则不是二叉搜索树

时间复杂度：O(n)，n为二叉树节点个数，一次遍历每个节点访问一次

空间复杂度：O(n)，worst case下栈中最多需要存储n个节点

------

102-二叉树的层序遍历

重点：二叉树的遍历，层序遍历

时间复杂度：O(n)，n为二叉树节点个数

空间复杂度：O(n)

------

103-二叉树的锯齿形层序遍历

重点：二叉树的遍历，层序遍历

在102的基础上加一个判断顺序的变量，每层改用双端队列

时间复杂度：O(n)，n为二叉树节点个数

空间复杂度：O(n)，渐进复杂度了，并不是太精确感觉（毕竟队列中最多只有两层的节点）

------

105-从前序与中序遍历序列构造二叉树

重点：二叉树的遍历，前序遍历，中序遍历

**递归**的做法比较容易想到，只需要知道前序遍历和中序遍历的特点：

前序遍历：[root，左子树，右子树]

中序遍历：[左子树，root，右子树]

实现细节：用一个哈希表存储每个值在inorder中出现的位置，方便快速查找。

时间复杂度：O(n)，n为二叉树节点个数

空间复杂度：O(n)，哈希表需要O(n)额外空间，递归栈空间O(h)（树深度）小于n，因此总体为O(n)

**迭代**的做法比较取巧

[官方解答](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/)非常详细，值得参考。

我个人理解的大致思路是这样的：

如果存在一棵只有左儿子的树，那么它的前序和中序结果顺序是**完全相反**的，如果在任意位置插入一个右儿子，对于前序遍历：右儿子在尾部。对于中序遍历：右儿子在**其父节点右边**。从这样一个性质中我们有这样的启发：

遍历前序结果，在出现与中序起点相同的结果后，代表这个一直向左的分支走到了尽头。接下来只需要找下一个节点是哪一个节点的右儿子：方法是使用栈存储前序遍历之前的所有结果，不断推出栈内元素的过程应该一直与中序遍历相同，出现不同的时候就是右儿子应该被插入的位置。

时间复杂度：O(n)，n为二叉树节点个数

空间复杂度：O(n)，最多有n个元素被推入栈中

------

106-从中序与后序遍历序列构造二叉树

重点：二叉树的遍历，中序遍历，后序遍历

**递归**的做法和q105略有不同。从后序遍历的尾部向前查询，只需要不断将postorderIndex减1，并先生成右子树，再生成左子树即可。（但完全按照q105的思路应该也能做？）

**迭代**的做法和q105思想基本相同。只不过要从后往前迭代。

时间复杂度：O(n)，两种做法都是O(n)复杂度

空间复杂度：O(n)

------

113-路径总和 II

重点：深度优先搜索，广度优先搜索

注意：DFS写简洁一点，java实现每次添加结果时要使用new关键字，回溯时记得删除操作

时间复杂度：O(n)，n为节点个数（虽然官方解答是n^2，但我更倾向于认同：每个节点只被增删一次）

空间复杂度：O(n)，取决于栈空间深度，最多不超过n

------

114-二叉树展开为链表

重点：二叉树

解决本题的关键在于理解二叉树是如何展开的：左子树最右最下的叶节点是右子树的父节点。然后根据这一点不断将左子树置空即可。

时间复杂度：O(n)，我认为worst case是一棵只有左儿子的二叉树，需要O(n)的移动操作次数

空间复杂度：O(1)，毕竟作为原地算法也不需要什么额外空间

------

116-填充每个节点的下一个右侧节点指针

重点：广度优先搜索，迭代

**BFS**的解法非常直观、简单，但空间复杂度不足（P.S.：层次遍历的重点在于用一个size变量记录本层有多少个节点）

时间复杂度：O(n)，每个节点存取一次

空间复杂度：O(n)，取决于队列需要的空间大小。完美二叉树最后一层有n/2个节点

第二种解法更好：通过上一层已建立的next指针，不断向右迭代构造新的next指针。这样做的理由在于，构造next指针其实只有两种情况：

- 同一个父节点下的左儿子通过next连接右儿子，即 node.left.next = node.right
- 节点的右儿子通过next连接该节点的next节点的左儿子，即 node.right.next = node.next.left

时间复杂度：O(n)，每个节点都会被遍历一次

空间复杂度：O(1)

------

117-填充每个节点的下一个右侧节点指针 II

重点：广度优先搜索，双指针

BFS和q116基本相同。

迭代的解法本质上是**双指针**，由于题目条件不再是完美二叉树，我们需要维护一个指示下一层的nextStart指针，以及一个指示本层前一个节点的last指针。

时间复杂度：O(n)

空间复杂度：O(1)

------

129-求根到叶子节点数字之和

重点：深度优先搜索

简单的DFS。（P.S.：这种问题就没必要搞回溯了）

时间复杂度：O(n)，每个节点访问一次

空间复杂度：O(n)，取决于栈空间深度，即二叉树深度，worst case二叉树深度为n

------

144-二叉树的前序遍历

重点：二叉树，前序遍历

**递归**的解法非常简单。

**迭代**的解法我目前看到了两个版本：

- 第一种是每次从栈中取出一个节点后，先后push右儿子和左儿子
- 第二种是每取得一个节点，一直向左走，将路径上的儿子全部push入栈，取出一个后再向右走（具体看代码就明白了）

Morris遍历之后有空的话可以看一下。

时间复杂度：O(n)，递归和迭代都是

空间复杂度：O(n)，递归和迭代都是

------

145-二叉树的后序遍历

重点：二叉树，后序遍历

**递归**略。

**迭代**的解法：使用一个prev指针指示是否已经遍历当前节点的所有左儿子和右儿子

时间复杂度：O(n)，递归和迭代都是

空间复杂度：O(n)，递归和迭代都是

------

173-二叉搜索树迭代器

重点：迭代器，二叉树，中序遍历

*题目要求：next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。*

从小到大遍历一个二叉搜索树，应该立刻想到**中序遍历**

**递归**解法就是额外创建一个List存储中序遍历结果，供next()调用就可以了

**迭代**解法就是额外创建一个栈，在调用next()时不光要返回数值，还要将当前节点右儿子及其所有左儿子一并推入栈中

时间复杂度：next() -- 递归解法O(1) / 迭代解法worst caseO(n)，均摊O(1)；hasNext() -- 均为O(1)

空间复杂度：递归解法O(n)额外空间 / 迭代解法O(h)，取决于BST高度

------

199-二叉树的右视图

重点：深度优先搜索，广度优先搜索

BFS解法非常容易想到。

DFS解法就是按照先右子树后左子树的方法搜索，加一个判断：当前深度是否初次到达，如果是初次到达那么此时的节点就是本层最右节点。

时间复杂度：O(n)，both

空间复杂度：O(n)，both

------

222-完全二叉树的节点个数

重点：二分查找，位运算

深度优先搜索显然没有利用完全二叉树的性质。

假设root在第0层，最深层为h。那么完全二叉树的节点范围在[2^h, 2^(h+1)-1]。只需要在这个范围内二分查找即可。

那么对于一个固定的值k，怎么知道第k个节点存不存在？使用Huffman树的特点，取得k的二进制表示，从高位到低位，除去最高位恒为1以外，0向左走，1向右走

注意：二分查找还是不熟练，条件为low < high时，取mid时需要向右取整，否则不收敛

注意：位运算优先级低于加减法，记得打括号

注意：root为第0层，不是第1层

时间复杂度：O(log2(n))，n为二叉树节点个数

空间复杂度：O(1)

------

226-翻转二叉树

重点：递归

时间复杂度：O(n)

空间复杂度：O(n)

------

230-二叉搜索树中第K小的元素

重点：中序遍历

时间复杂度：O(n)

空间复杂度：O(n)

------

235-二叉搜索树的最近公共祖先

重点：二叉搜索树

比较root、p、q储存的值，若root值在二者之间则root即为结果，否则向左或向右继续查找。

另一种做法：两次遍历，得到两条路径，找到路径最后一个相同的节点。

时间复杂度：O(n)

空间复杂度：O(1)，如果用两次遍历的做法就是O(n)（不划算）

------

236-二叉树的最近公共祖先

重点：递归，深度优先搜索

暴力一点的解法：DFS找到p和q的路径，比对路径

温和一点的解法：和q235思路相同，只不过需要用一个返回boolean的DFS判断root是否在p、q之间

温和解法中，有两种情况root为结果（本质就是q235）

- p和q一个在root的左子树，一个在root的右子树

- p和q一个就是root，另一个在root的子树中（左右均可）

官方解法中还有一个思路：用一个哈希表存储 所有节点 -> 父节点 的映射关系，不断向上查找获得路径，但我觉得和DFS暴力解法思路有较为相似之处：都是获得p和q的路径。

时间复杂度：O(n)，DFS遍历每个节点一次

空间复杂度：O(n)，DFS的worst case栈空间O(n)。暴力解法需要存储路径，在常系数上比温和解法差

------

109-有序链表转换二叉搜索树

重点：分治，快慢指针，中序遍历

要构建高度平衡的BST，取链表中点作为root，左侧构建左子树，右侧构建右子树，这就形成了一个分治问题。

接下来的问题无非是如何取得链表中点：

- 解法1：快慢指针，O(n)复杂度
- 解法2：利用中序遍历特点，先生成左子树，然后是root，最后生成右子树，那么生成的root顺序一定和链表顺序是相同的，O(1)复杂度

时间复杂度：

- 解法1：递推公式 T(n) = 2 T(n/2) + O(n)，解得O(nlog(n))（计算方法：两边同时除以n）
- 解法2：递推公式 T(n) = 2 T(n/2) + O(1)，解得O(n)

空间复杂度：O(log n)，递归栈空间



